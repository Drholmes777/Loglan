
#5/26 revisions to repair bugs found in the course of editing the new
# agenda document and in the course of subsequent testing of complex
# parses.  There are likely plenty of bugs!

# 5/25 fixed bug in medial freemods in high level sentences which was
# cancelled by a bug in the ML parser.  Also, improved name marker situation.

#  5/24/2014  phonetic version, now the official release.  It recognizes the ends
# of explicitly stressed predicates without whitespace.  I still have a problem
# with stress patterns in borrowing/derived affixes.  It has more compact
# display.  It parses the corpus with a couple of failures which can be
# fixed by removing commas:  these should work soon.  It may have bugs
# in predicate parsing as I completely rebuilt the method of parsing
# both borrowings and complexes.

# 5/23/2014 -- I have edited this file directly.  I will shortly
# export the changes back into the ML version.  This program now
# recognizes the ends of predicates without using whitespace when explicit
# stresses are given.  There may be bugs (because the method of parsing
# predicates was entirely overhauled, which will inevitably create bugs,
# and because there are new and largely untested features (junctures
# and stresses).

# junctures and stresses fully installed in names.  Junctures installed
# in borrowings.  Additional constraint on final consonant pairs installed.
# added terminal comma in LI quotes  Added ability to pause after GA

# massive revisions to support junctures in cmapua in a sensible way.  Installed LAO
# words (with mandatory y separating components):  LAO ALBERT Y EINSTEIN.  Made vocalic consonant
# pairs individual units.

# I now need to compact lots of word classes by default, because cmapua are parsed down to letters

# just fixed __LWbreak to handle all vowel initial words

# detected and fixed subtle bug which misread complexes with four letter djifoa in them
# as containing borrowings, because the Consonantfinal test wasnt working correctly.

# work order:  if I could duplicate the PEG file generation (with comments) and the termination checking
# in peg.py I could work entirely in Python.

# KOUKI words added 5/4  JO construction added 5/5  space after MIE 5/6
# repairing left grouping of logically connected predicates 5/7
# various fixes to quotation constructions 5/7

#5/8 restored more flexibility re final shared termsets
# to predicate2 and backpred

#5/17 allowing negation of argmods; further, added other modes
# of the interrogative connective HA.

# "no structure word breaks" version
# close all PA suffixed connectives with GU, PA words with JUU when needed, PA alone modifiers with GUU
# numbers with PUI when needed; PAUSE becomes a freemod.  LWbreak is minimal:  checks odd vowel
# condition, checks no following A word, allows a comma (then followed by an A word).  PAUSE/GU equivalence still exists but seems seldom
# actually to happen.   Corpus so far parses with minimal changes.  Also installed moa followed by 

# removed final occurrences of freemod in most cases.  This version
# should do pause/GU equivalence fairly well.  Should look at medial
# occurrences of freemod to see which ones should not be allowed to
# be pauses.

# version of 4/22/2014

# added indented display setting, and debugged the Shallow option
# so that shallow displays look much nicer.

# Use Utter command (as in corpus) to get a good display

#  updated grammar to eliminate duplicate rules due to the old
# machine grammar

# added different default state of parser which makes parses
# somewhat more compact though not altogether consistently

# the grammar rules are now automatically generated by the ML version, so
# they *will* match properly.

# this file contains intellectual property of
# Randall Holmes and the Loglan Institute
# to which all rights are reserved, though private noncommercial
# use of the files to parse Loglan is encouraged (and speakers of
# That Other Language are welcome to adapt this if they find it useful).

# capabilities here are still limited.  Notice that you need peg.py
# too to run this file.

# utter(' <string> ') will parse a string as Loglan grammar class 'utterance'
# It is now better to use Utter rather than utter
#  Verbose() will toggle whether grammar classes are shown or not and
#  Shallow() will toggle the depth of the display (nested grammar classes
# are not all shown in the shallow mode).  The verbose deep mode is very
# thoroughly annotated!

# utteras('<classname>','<text>') will parse the text using the indicated
# Loglan grammar class rather than utterance.

# Compact('<classname>') will cause things which parse as class <classname>
# to display as entirely unlabelled strings (make blanu into a single word 
# by compacting
# Predicate).  Decompact() will clear all compact display instructions.

#  Showrule('<classname>') shows a rule <classname> of the Loglan grammar
# in PEG notation

#  More functions will be added!

# this installs the entire grammar as of 3/3/2014 and appears
# to work.

# Loglan grammar workspace

# from peg import *

# insert entire peg.py file

#  version of 4/22/2014  1:01 PM desktop

# added greedy parsing option

# added indented display
#  changed shallow so it shows outermost class only, reduces clutter
#  further changes to Shallow display.   4/21 further fine-tuning of
#  shallow display and fixed the recursion so it runs at acceptable speed.

#  corrected shallow printing so it works sensibly with compacted classes
#  (just added work orders for new features at end)

#useful settings:

# Verbose() toggles display of grammar class names
# Shallow() makes the grammar display shallower in a way that is best
# found out by using it
# Numberbrackets() puts numbers <n> next to brackets indicating depth
# Indent() turns on indented display
# Compact (<name of grammar class>) will cause it to display that class
# as an unlabelled unparsed string
# Decompact() turns off all Compact settings

# Greedy() toggles greedy parsing, which always takes the first permissible
# alternative which is *longest*.  A difference between greedy and regular parsing
# indicates a formal problem with the grammar.  Greedy parsing is *slow*

# This file provides PEG parsing services for loglan.py.  User
# advice appears in loglan.py.   This file contains intellectual property
# of Randall Holmes, to which all rights are reserved, though I have no
# objection to anyone playing with it for noncommercial purposes (such as
# the intended application to Loglan).

#  implement PEG parsers for the Loglan grammar and other applications

peggrammar={}  #this is the index of defined classes for the PEG language

def charlistfind(c,L):
    if len(L)==0:  return False
    if (L[0][0]==c or L[0][0]<c) and (L[0][1]==c or L[0][1]>c): return True
    return charlistfind(c,L[1:])

# parser output is a list of two elements, the first a list of items
# (recording parse information) the second the remainder of the string
# still to be consumed

# a proper parser expression is a list of one or two items

# caching is crucial to reasonable performance!  Every parse
# done with an identifier is saved, key being the rule and the string being
# parsed

# features of the ML version should be added:  the circularity checker
# is really useful, and the greedy option would be useful and easy to
# install.  It desperately needs sensible parse display.

thecache={}
label=0
greedy=False

def Greedy():
    global greedy
    greedy=not(greedy)

def parse(thegrammar,expression,string):
   global thecache
   global greedy
   # ['literal',string]

   if len (expression) == 0 or len(expression)>2 :  return 'bad expression'

   if expression[0]=='literal':
       s=expression[1]
       if len(string)<len(s): return 'fail'
       if string[0:len(s)]==s:
           return [[s],string[len(s):]]
       return 'fail'
   if expression[0]=='class':
       L=expression[1]  #L is a list of pairs of characters
       if len(string)==0:
           if L == []:  return ''
           return 'fail'
       if charlistfind(string[0],L)==True:
           return [[string[0]],string[1:]]
       return 'fail'
   if expression[0]=='dot':
        if len(string)==0:
            return 'fail'
        return [[string[0]],string[1:]]
   if expression[0]=='sequence':
        L=expression[1]
        if len(L)==0:
            return [[],string]
        M=parse(thegrammar,L[0],string)
        if M=='fail':  return 'fail'
        N=parse(thegrammar,['sequence',L[1:]],M[1])
        if N=='fail':  return 'fail'
        return [M[0]+N[0],N[1]]
   if expression[0]=='alternatives' and greedy == False:
        L=expression[1]
        if len(L)==0:  return 'fail'
        M=parse(thegrammar,L[0],string)
        if M=='fail':  return parse(thegrammar,['alternatives',L[1:]],string)
        return M
   if expression[0]=='alternatives' and greedy == True:
        L=expression[1]
        if len(L)==0:  return 'fail'
        M2=parse(thegrammar,['alternatives',L[1:]],string)
        M1=parse(thegrammar,L[0],string)
        if M2=='fail': return M1
        if M1=='fail': return M2
        if len(M2[1])<len(M1[1]):  return M2
        return M1
   if expression[0]=='not':
        M = parse(thegrammar,expression[1],string)
        if M=='fail':  return [[],string]
        return 'fail'
   if expression[0]=='and':
        M = parse(thegrammar,expression[1],string)
        if M=='fail':  return 'fail'
        return [[],string]
   if expression[0]=='optional':
        M= parse(thegrammar,expression[1],string)
        if M=='fail': return [[],string]
        return M
   if expression[0]=='zeroormore':
        M=parse(thegrammar,expression[1],string)
        if M=='fail':  return [[],string]
        if M[1]==string:  return [[],string]
        N=parse(thegrammar,expression,M[1])
        return [M[0]+N[0],N[1]]
   if expression[0]=='oneormore':
        M=parse(thegrammar,expression[1],string)
        if M=='fail':  return 'fail'
        N=parse(thegrammar,['zeroormore',expression[1]],M[1])
        return [M[0]+N[0],N[1]]
   if expression[0]=='identifier':
        if not expression[1] in thegrammar.keys():
            print('bad class name '+expression[1])
            return 'fail'
        if (expression[1],string) in thecache.keys():
            return thecache[(expression[1],string)]
        M=parse(thegrammar,thegrammar[expression[1]],string)
        if M=='fail':  return 'fail'
        thecache[(expression[1],string)]=[[[label,expression[1],M[0]]],M[1]]
        return [[[label,expression[1],M[0]]],M[1]]
   print ('badly formed expression encountered '+str(expression[0]))
   return 'fail'
        
def showrule(expression):

    #  this actually needs a clause to determine which quote to use
    if expression[0]=='literal':  return "'"+expression[1]+"'"
    if expression[0]=='class':
        if len(expression[1])==0:  return '[]'
        if len(expression[1])==1:
            if expression[1][0][0]==expression[1][0][1]:
               return '['+expression[1][0][0]+']'
            return '['+  expression[1][0][0]+'-'+expression[1][0][1]+ ']'
        if expression[1][0][0]==expression[1][0][1]: return '['+expression[1][0][0]+showrule(['class',expression[1][1:]])[1:]
        return '['+expression[1][0][0]+'-'+expression[1][0][1]+showrule(['class',expression[1][1:]])[1:]
    if expression[0]=='dot':  return '.'
    if expression[0]=='sequence':
        if len(expression[1])==0:  return '()'
        if len(expression[1])==1:  return '('+showrule(expression[1][0])+')'
        return '('+showrule(expression[1][0])+' '+showrule(['sequence',expression[1][1:]])[1:]
    if expression[0]=='alternatives':
        if len(expression[1])==1:  return '('+showrule(expression[1][0])+')'
        return '('+showrule(expression[1][0])+'/'+showrule(['alternatives',expression[1][1:]])[1:]
    if expression[0]=='not':  return '!'+showrule(expression[1])
    if expression[0]=='and':  return '&'+showrule(expression[1])
    if expression[0]=='optional':  return showrule(expression[1])+'?'
    if expression[0]=='zeroormore':  return showrule(expression[1])+'*'
    if expression[0]=='oneormore':  return showrule(expression[1])+'+'
    if expression[0]=='identifier':  return expression[1]



def additem1(thegrammar,name,R):
    thegrammar[name]=R

# manually building the parser of PEG expressions -- bootstrap time!

# mod errors, here is Ford's grammar of PEG expressions, minus ASCII escape sequences

additem1(peggrammar,'Grammar',['sequence',[['identifier','Spacing'],['oneormore',['identifier','Definition']],['identifier','EndOfFile']]])


additem1(peggrammar,'Definition',['sequence',[['identifier','Identifier'],['identifier','LEFTARROW'],['identifier','Expression']]])

additem1(peggrammar,'Expression',['sequence',[['identifier','Sequence'],['zeroormore',['sequence',[['identifier','SLASH'],['identifier','Sequence']]]]]])

additem1(peggrammar,'Sequence',['zeroormore',['identifier','Prefix']])

additem1(peggrammar,'Prefix',['sequence',[['optional',['alternatives',[['identifier','AND'],['identifier','NOT']]]],['identifier','Suffix']]])

additem1(peggrammar,'Suffix',['sequence',[['identifier','Primary'],['optional',['alternatives',[['identifier','QUESTION'],['identifier','STAR'],['identifier','PLUS']]]]]])

additem1(peggrammar,'Primary',['alternatives',[['sequence',[['identifier','Identifier'],['not',['identifier','LEFTARROW']]]],
                ['sequence',[['identifier','OPEN'],['identifier','Expression'],['identifier','CLOSE']]],
                ['identifier','Literal'],['identifier','Class'],['identifier','DOT']]])
additem1(peggrammar,'Identifier',['sequence',[['identifier','IdentStart'],['zeroormore',['identifier','IdentCont']],['identifier','Spacing']]])

additem1(peggrammar,'IdentStart',['class',[['a','z'],['A','Z'],['_','_']]])

additem1(peggrammar,'IdentCont',['alternatives',[['identifier','IdentStart'],['class',[['0','9']]]]])

additem1(peggrammar,'Literal',['alternatives',[['sequence',[['literal',"'"],['zeroormore',['sequence',[['not',['literal',"'"]],['identifier','Char']]]],['literal',"'"],['identifier','Spacing']]],
         ['sequence',[['literal','"'],['zeroormore',['sequence',[['not',['literal','"']],['identifier','Char']]]],['literal','"'],['identifier','Spacing']]]]])

additem1(peggrammar,'Class',['sequence',[['literal','['],['zeroormore',['sequence',[['not',['literal',']']],['identifier','Range']]]],['literal',']'],['identifier','Spacing']]])

additem1(peggrammar,'Range',['alternatives',[['sequence',[['identifier','Char'],['literal','-'],['identifier','Char']]],['identifier','Char']]])

#  I left out ASCII code escape sequences from the PEG expression grammar as I will not make use of them

additem1(peggrammar,'Char',['alternatives',
                 [['sequence',[['literal','\\'],['class',[['n','n'],['r','r'],['t','t'],["'","'"],['[','['],[']',']'],['\\','\\']]]]],
                  ['sequence',[['not',['literal','\\']],['dot']]]]])

additem1(peggrammar,'LEFTARROW',['sequence',[['literal','<-'],['identifier','Spacing']]])
additem1(peggrammar,'SLASH',['sequence',[['literal','/'],['identifier','Spacing']]])
additem1(peggrammar,'AND',['sequence',[['literal','&'],['identifier','Spacing']]])
additem1(peggrammar,'NOT',['sequence',[['literal','!'],['identifier','Spacing']]])
additem1(peggrammar,'QUESTION',['sequence',[['literal','?'],['identifier','Spacing']]])
additem1(peggrammar,'STAR',['sequence',[['literal','*'],['identifier','Spacing']]])
additem1(peggrammar,'PLUS',['sequence',[['literal','+'],['identifier','Spacing']]])
additem1(peggrammar,'OPEN',['sequence',[['literal','('],['identifier','Spacing']]])
additem1(peggrammar,'CLOSE',['sequence',[['literal',')'],['identifier','Spacing']]])
additem1(peggrammar,'DOT',['sequence',[['literal','.'],['identifier','Spacing']]])

additem1(peggrammar,'Spacing',['zeroormore',['alternatives',[['identifier','Space'],['identifier','Comment']]]])

additem1(peggrammar,'Comment',
         ['sequence',[['literal','#'],['zeroormore',['sequence',[['not',['identifier','EndOfLine']],['dot']]]],['identifier','EndOfLine']]])

additem1(peggrammar,'Space',['alternatives',[['literal',' '],['literal','\t'],['identifier','EndOfLine']]])

additem1(peggrammar,'EndOfLine',['alternatives',[['literal','\r\n'],['literal','\n'],['literal','\r']]])

additem1(peggrammar,'EndOfFile',['not',['dot']])


# I then need a function which will convert PEG expression parses into the internal representation of expressions

def getchar(P):
    if (not P[0]==label) or not (P[1]=='Char'):
        print('bad character')
        return ' '
    if len(P[2])==1: return P[2][0][0]
    if P[2][1]=='n':  return '\n'
    if P[2][1]=='t':  return '\t'
    if P[2][1]=='r':  return '\r'
    return P[2][1]

def getchar2(P):
    if len(P)==1 and len(P[0])==1:  return P[0]
    if len(P)==1:  return getchar2(P[0])
    return getchar2(P[2])

def getrange(R):
    if len(R[2])==1:  return [getchar(R[2][0]),getchar(R[2][0])]
    return [getchar(R[2][0]),getchar(R[2][2])]

def parsetopeg(P):
    if len(P)==1 and P[0][0]==label:  return parsetopeg(P[0])
    if P[1]=='Expression':
        if len(P[2])==0: return ['bad']
        if len(P[2])==1:  return parsetopeg(P[2][0])
        if len(P[2])==3:  return ['alternatives',[parsetopeg(P[2][0]),parsetopeg(P[2][2])]]
        return ['alternatives',list([parsetopeg(P[2][0])])+ parsetopeg([P[0],P[1],P[2][2:]])[1]]
    if P[1]=='Sequence':
        # zero length is quite possible for sequences
        if len(P[2])==1:  return parsetopeg(P[2][0])
        return ['sequence',list(map(parsetopeg,P[2]))]
    if P[1]=='Prefix':
        if P[2][0][1]=='AND':  return ['and',parsetopeg(P[2][1])]
        if P[2][0][1]=='NOT':  return ['not',parsetopeg(P[2][1])]
        return parsetopeg(P[2][0])
    if P[1]=='Primary':
        if P[2][0][1]=='OPEN':  return parsetopeg (P[2][1])
        return parsetopeg (P[2][0])
    if P[1]=='Suffix':
        if len(P[2])==1:  return parsetopeg(P[2][0])
        if P[2][1][1]=='QUESTION':  return ['optional',parsetopeg(P[2][0])]
        if P[2][1][1]=='STAR':  return ['zeroormore',parsetopeg(P[2][0])]
        if P[2][1][1]=='PLUS':  return ['oneormore',parsetopeg(P[2][0])]
    if P[1]=='Identifier':
        if P[2][0][1]=='Spacing':  return ['identifier','']
        return ['identifier',getchar2(P[2][0][2])+parsetopeg([P[0],P[1],P[2][1:]])[1]]
    if P[1]=='Literal':
        if P[2][1]=='"' or P[2][1]=="'":  return ['literal','']
        return ['literal',getchar(P[2][1])+((parsetopeg([P[0],P[1],[P[2][0]]+P[2][2:]]))[1])]
    if P[1]=='Class':
        return ['class',list(map(getrange,P[2][1:-2]))]
    if P[1]=='DOT':  return ['dot']
    return ['fail']

def classtest(s):
    return parsetopeg(parse(peggrammar,['identifier','Expression'],s)[0])



def rundef(thegrammar,s):
    
    T=parse(peggrammar,['identifier','Definition'],s)
    if T[0]=='fail' or not T[1]=='':
        print('Failed to define '+s)
        return 'failed'
    
    additem1(thegrammar,parsetopeg(T[0][0][2][0])[1],parsetopeg(T[0][0][2][2]))



def Parse(thegrammar,rule, string):
#   thecache.clear()
    return parse(thegrammar,thegrammar[rule],string)

compactclasses=[]

def Compact(s):
    global compactclasses
    compactclasses=[s]+compactclasses

def Decompact():
    global compactclasses
    compactclasses=[]

verbose=True

shallow=False

def Verbose():
    global verbose
    verbose=not(verbose)

def Shallow():
    global shallow
    shallow=not(shallow)

def declutter(P):
    if len(P)==0:  return []
    if P==' ': return []
    if P==str(P):  return P
    if len(P)==1:
        R=declutter(P[0])
        if R==' ' or R==[' ']:  return []
        if R==str(R):  return [R]
        return R
    if P[0]==label:
        if len(P[2])==0 or P[2]==' ' or P[2]==[' ']:  return []
        if P[1] in compactclasses:  return P
        if P[2]==str(P[2]):  return P
        W= declutter(P[2])
        if len(W)==1: W=W[0]
        if len(W)==0 or W== ' ' or W==[' ']:  return []
        if W==str(W): return [P[0],P[1],W]
        if W[0]==label:
            Q=(W[2])
            if len(Q)==1:  Q =Q[0]
            if len(Q)==0 or Q==' ' or Q==[' ']:  return []
            if W[1] in compactclasses:  return [P[0],P[1],W]
            if Q==str(Q):  return [P[0],P[1],W]
            if Q[0]==label and Q[1] in compactclasses:  return [P[0],P[1],W]
            if Q[0]==label:  return ([P[0],P[1],Q])
            if W==P[2]:  return P
            return [P[0],P[1],Q]
        return ([P[0],P[1],W])
    Q=declutter(P[0])
    if Q==[] or Q==' ' or Q==[' ']:  return declutter(P[1:])
    X=declutter(P[1:])
    if X==[] and not Q==str(Q): return Q
    return [Q]+declutter(P[1:])

def compactprint(P):
    if len(P)==0:  return ''
    if P==str(P):  return P
    if len(P)==1:  return compactprint(P[0])
    if P[0]==label:  return compactprint(P[2])
    return compactprint(P[0])+compactprint(P[1:])

numberbrackets=False

def Numberbrackets():
    global numberbrackets
    numberbrackets=not(numberbrackets)

def bracketnumber(n):
    global numberbrackets
    if numberbrackets==True: return '<'+str(n)+'>'
    return ''

indent=False
def Indent():
    global indent
    indent=not(indent)

indentlevel=3

def spaces(n):
    if n==0:  return ''
    return ' '+spaces(n-1)

def indenting(n):
    if indent==False:  return ''
    if n==0: return "\n"
    return indenting(n-1)+spaces(indentlevel)

def printparse0(n,P):
    global compactclasses
    global verbose
    global shallow
    global numberbrackets
    if len(P)==0:  return ''
    if P==str(P):  return indenting(n)+P
    if len(P)==1:  return printparse0(n,P[0])
    if P[0]==label:
        if P[1] in compactclasses:  return indenting(n)+compactprint(P)
        if declutter(P)==[]:  return ''
        if verbose==False:
            if shallow==True:  return indenting(n)+'['+bracketnumber(n)+printparse0(n+1,declutter(P[2]))+bracketnumber(n)+']'
            return indenting(n)+'['+bracketnumber(n)+printparse(n+1,P[2])+bracketnumber(n)+']'
        if shallow==True:  return indenting(n)+'['+bracketnumber(n)+P[1]+':'+printparse0(n+1,declutter(P[2]))+bracketnumber(n)+']'
#use core instead of core2 in line above for just outermost classes
        return indenting(n)+'['+bracketnumber(n)+P[1]+':'+printparse0(n+1,P[2])+bracketnumber(n)+']'
    A=printparse0(n,P[0])
    B=printparse0(n,P[1:])
    if A=='':  return B
    if B=='':  return A
    return A+' '+B

def printparse(P):  return printparse0(1,P)

# work orders:  the termination check of the ML version is really useful.  Probably file I/O commands would also be useful,
# though it seems that this version will be slaved to the ML version for now, since I can now export files thence to here.

# more feedback from commands will be useful.


loglan={}

def L(s):  rundef(loglan,s)

def utter(s):
    global verbose
    global shallow
    return printparse(Parse(loglan,'utterance',s))

def utteras(c,s):
    return printparse(Parse(loglan,c,s))

def Showrule(s):
    print(showrule(loglan[s]))

Shallow()

Compact('Predicate')

Compact('Name')

Compact('A')
Compact('ACI')
Compact('Acronym')
Compact('AGE')
Compact('BI')
Compact('CA')
Compact('CI')
Compact('CUI')
Compact('NI')
Compact('DA')
Compact('DIO')
Compact('DIE')
Compact('LIO')
Compact('GA')
Compact('GE')
Compact('GU')
Compact('GI')
Compact('GO')
Compact('GUE')
Compact('GUI')
Compact('GUO')
Compact('GUU')
Compact('HOI')
Compact('HOI0')
Compact('ICA')
Compact('ICI')
Compact('IE1')
Compact('IGE')
Compact('JE')
Compact('JI')
Compact('JIO')
Compact('JO')
Compact('JUE')
Compact('KA')
Compact('KI')
Compact('KIE')
Compact('KIU')
Compact('LAU')
Compact('stringnospaces')
Compact('LW')
Compact('LWPREDA')
Compact('LUA')
Compact('LI1')
Compact('LU1')
Compact('LIE1')
Compact('CII1')
Compact('LAO1')
Compact('LIU0')
Compact('SOI')
Compact('ME')
Compact('LEPO')
Compact('NOUI')
Compact('UI1')
Compact('NO1')
Compact('mex')
Compact('NU')
Compact('PA2')
Compact('RA')
Compact('LE')
Compact('LA')
Compact('LA0')
Compact('I')
Compact('GA2')
Compact('CANCELPAUSE')
Compact('PO')
Compact('POSHORT')
Compact('HUE')
Compact('SUE')
Compact('ZE2')





















Indent()

# Greedy()  # will parse slowly, a disagreement with the usual parse
#indicates a formal problem with the grammar

# Verbose()  #this would suppress class names

def Utter(x):
    print(x)
    print(' ')
    print(utter(x))
    print('------')

def Utteras(c,x):
    print(x)
    print(' ')
    print(utteras(c,x))
    print('------')

def borrow(s):
    Utteras('Borrowing',s)

def interface():
    item=input('Type an utterance to parse (or ... to exit):\n')
    if not (item=='...'): Utter(item)
    if not (item=='...'):  interface()



L("lowercase <- (!([qwx]) [a-z])")

L("uppercase <- (!([QWX]) [A-Z])")

L("letter <- (!([QWXqwx]) [A-Za-z])")

L("juncture <- ((([-] &(letter)) / ([\'] !((([ ])* Predicate)) (([ ,] ([ ])* &(Predicate)))?)) !(juncture))")

L("Lowercase <- (lowercase / juncture)")

L("Letter <- (letter / juncture)")

L("period <- ([!.:;?] !((([ ])* period)))")

L("B <- [Bb]")

L("C <- [Cc]")

L("D <- [Dd]")

L("F <- [Ff]")

L("G <- [Gg]")

L("H <- [Hh]")

L("J <- [Jj]")

L("K <- [Kk]")

L("L <- [Ll]")

L("M <- [Mm]")

L("N <- [Nn]")

L("P <- [Pp]")

L("R <- [Rr]")

L("S <- [Ss]")

L("T <- [Tt]")

L("V <- [Vv]")

L("Z <- [Zz]")

L("a <- ([Aa] (juncture)?)")

L("e <- ([Ee] (juncture)?)")

L("i <- ([Ii] (juncture)?)")

L("o <- ([Oo] (juncture)?)")

L("u <- ([Uu] (juncture)?)")

L("AA <- ([Aa] (juncture)? [a] (juncture)?)")

L("AE <- ([Aa] (juncture)? [e] (juncture)?)")

L("AI <- ([Aa] [i] (juncture)?)")

L("AO <- ([Aa] [o] (juncture)?)")

L("AU <- ([Aa] (juncture)? [u] (juncture)?)")

L("EA <- ([Ee] (juncture)? [a] (juncture)?)")

L("EE <- ([Ee] (juncture)? [e] (juncture)?)")

L("EI <- ([Ee] [i] (juncture)?)")

L("EO <- ([Ee] (juncture)? [o] (juncture)?)")

L("EU <- ([Ee] (juncture)? [u] (juncture)?)")

L("IA <- ([Ii] (juncture)? [a] (juncture)?)")

L("IE <- ([Ii] (juncture)? [e] (juncture)?)")

L("II <- ([Ii] (juncture)? [i] (juncture)?)")

L("IO <- ([Ii] (juncture)? [o] (juncture)?)")

L("IU <- ([Ii] (juncture)? [u] (juncture)?)")

L("OA <- ([Oo] (juncture)? [a] (juncture)?)")

L("OE <- ([Oo] (juncture)? [e] (juncture)?)")

L("OI <- ([Oo] [i] (juncture)?)")

L("OO <- ([Oo] (juncture)? [o] (juncture)?)")

L("OU <- ([Oo] (juncture)? [u] (juncture)?)")

L("UA <- ([Uu] (juncture)? [a] (juncture)?)")

L("UE <- ([Uu] (juncture)? [e] (juncture)?)")

L("UI <- ([Uu] (juncture)? [i] (juncture)?)")

L("UO <- ([Uu] (juncture)? [o] (juncture)?)")

L("UU <- ([Uu] (juncture)? [u] (juncture)?)")

L("V1 <- [AEIOUYaeiouy]")

L("V2 <- [AEIOUaeiou]")

L("C1 <- (!(V1) letter)")

L("Mono <- (([Aa] [o]) / (V2 [i]) / ([Ii] V2) / ([Uu] V2))")

L("EMono <- (([Aa] [o]) / ([AEIaei] [i]))")

L("NextVowels <- (EMono / (V2 &(EMono)) / Mono / V2)")

L("BrokenMono <- (([a] juncture [o]) / ([aeo] juncture [i]))")

L("CVVSyll <- (C1 Mono)")

L("LWunit <- (((CVVSyll (juncture)? V2) / (C1 !(BrokenMono) V2 (juncture)? V2) / (C1 V2)) (juncture)?)")

L("LW1 <- (((V2 V2) / (C1 !(BrokenMono) V2 (juncture)? V2) / (C1 V2)) (juncture)?)")

L("caprule <- ((uppercase / lowercase) ((lowercase / juncture))* !(letter))")

L("InitialCC <- ('bl' / 'br' / 'ck' / 'cl' / 'cm' / 'cn' / 'cp' / 'cr' / 'ct' / 'dj' / 'dr' / 'dz' / 'fl' / 'fr' / 'gl' / 'gr' / 'jm' / 'kl' / 'kr' / 'mr' / 'pl' / 'pr' / 'sk' / 'sl' / 'sm' / 'sn' / 'sp' / 'sr' / 'st' / 'tc' / 'tr' / 'ts' / 'vl' / 'vr' / 'zb' / 'zv' / 'zl' / 'sv' / 'Bl' / 'Br' / 'Ck' / 'Cl' / 'Cm' / 'Cn' / 'Cp' / 'Cr' / 'Ct' / 'Dj' / 'Dr' / 'Dz' / 'Fl' / 'Fr' / 'Gl' / 'Gr' / 'Jm' / 'Kl' / 'Kr' / 'Mr' / 'Pl' / 'Pr' / 'Sk' / 'Sl' / 'Sm' / 'Sn' / 'Sp' / 'Sr' / 'St' / 'Tc' / 'Tr' / 'Ts' / 'Vl' / 'Vr' / 'Zb' / 'Zv' / 'Zl' / 'Sv')")

L("MaybeInitialCC <- (([Bb] (juncture)? [l]) / ([Bb] (juncture)? [r]) / ([Cc] (juncture)? [k]) / ([Cc] (juncture)? [l]) / ([Cc] (juncture)? [m]) / ([Cc] (juncture)? [n]) / ([Cc] (juncture)? [p]) / ([Cc] (juncture)? [r]) / ([Cc] (juncture)? [t]) / ([Dd] (juncture)? [j]) / ([Dd] (juncture)? [r]) / ([Dd] (juncture)? [z]) / ([Ff] (juncture)? [l]) / ([Ff] (juncture)? [r]) / ([Gg] (juncture)? [l]) / ([Gg] (juncture)? [r]) / ([Jj] (juncture)? [m]) / ([Kk] (juncture)? [l]) / ([Kk] (juncture)? [r]) / ([Mm] (juncture)? [r]) / ([Pp] (juncture)? [l]) / ([Pp] (juncture)? [r]) / ([Ss] (juncture)? [k]) / ([Ss] (juncture)? [l]) / ([Ss] (juncture)? [m]) / ([Ss] (juncture)? [n]) / ([Ss] (juncture)? [p]) / ([Ss] (juncture)? [r]) / ([Ss] (juncture)? [t]) / ([Tt] (juncture)? [c]) / ([Tt] (juncture)? [r]) / ([Tt] (juncture)? [s]) / ([Vv] (juncture)? [l]) / ([Vv] (juncture)? [r]) / ([Zz] (juncture)? [b]) / ([Zz] (juncture)? [v]) / ([Zz] (juncture)? [l]) / ([Ss] (juncture)? [v]))")

L("NonmedialCC <- (([b] (juncture)? [b]) / ([c] (juncture)? [c]) / ([d] (juncture)? [d]) / ([f] (juncture)? [f]) / ([g] (juncture)? [g]) / ([h] (juncture)? [h]) / ([j] (juncture)? [j]) / ([k] (juncture)? [k]) / ([l] (juncture)? [l]) / ([m] (juncture)? [m]) / ([n] (juncture)? [n]) / ([p] (juncture)? [p]) / ([q] (juncture)? [q]) / ([r] (juncture)? [r]) / ([s] (juncture)? [s]) / ([t] (juncture)? [t]) / ([v] (juncture)? [v]) / ([z] (juncture)? [z]) / ([h] (juncture)? C1) / ([cjsz] (juncture)? [cjsz]) / ([f] (juncture)? [v]) / ([k] (juncture)? [g]) / ([p] (juncture)? [b]) / ([t] (juncture)? [d]) / ([fkpt] (juncture)? [jz]) / ([b] (juncture)? [j]) / ([s] (juncture)? [b]))")

L("NonjointCCC <- (([c] (juncture)? [d] (juncture)? [z]) / ([c] (juncture)? [v] (juncture)? [l]) / ([n] (juncture)? [d] (juncture)? [j]) / ([n] (juncture)? [d] (juncture)? [z]) / ([d] (juncture)? [c] (juncture)? [m]) / ([d] (juncture)? [c] (juncture)? [t]) / ([d] (juncture)? [t] (juncture)? [s]) / ([p] (juncture)? [d] (juncture)? [z]) / ([g] (juncture)? [t] (juncture)? [s]) / ([g] (juncture)? [z] (juncture)? [b]) / ([s] (juncture)? [v] (juncture)? [l]) / ([j] (juncture)? [d] (juncture)? [j]) / ([j] (juncture)? [t] (juncture)? [c]) / ([j] (juncture)? [t] (juncture)? [s]) / ([j] (juncture)? [v] (juncture)? [r]) / ([t] (juncture)? [v] (juncture)? [l]) / ([k] (juncture)? [d] (juncture)? [z]) / ([v] (juncture)? [t] (juncture)? [s]) / ([m] (juncture)? [z] (juncture)? [b]))")

L("RepeatedVowel <- (([Aa] (juncture)? [a]) / ([Ee] (juncture)? [e]) / ([Oo] (juncture)? [o]))")

L("RepeatedVocalic <- (([Mm] [m]) / ([Nn] [n]) / ([Ll] [l]) / ([Rr] [r]))")

L("Syllabic <- [lmnr]")

L("Nonsyllabic <- (!(Syllabic) C1)")

L("Badfinalpair <- (Nonsyllabic !('mr') !(RepeatedVocalic) Syllabic !((V2 / [y] / RepeatedVocalic)))")

L("FirstConsonants <- (((!((C1 C1 RepeatedVocalic)) &(InitialCC) (C1 InitialCC)) / (!((C1 RepeatedVocalic)) InitialCC) / ((!(RepeatedVocalic) C1) !([y]))) !(juncture))")

L("FirstConsonants2 <- (((!((C1 C1 RepeatedVocalic)) &(InitialCC) (C1 InitialCC)) / (!((C1 RepeatedVocalic)) InitialCC) / (!(RepeatedVocalic) C1)) !(juncture))")

L("VowelSegment <- (NextVowels / RepeatedVocalic)")

L("Syllable <- (((FirstConsonants)? VowelSegment !(Badfinalpair) (FinalConsonant)? (FinalConsonant)?) (juncture)?)")

L("JunctureFix <- (C1 V2 juncture &(InitialCC))")

L("SyllableFinal1 <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment ([-])? (&(Syllable) / [y] / !(letter)))")

L("SyllableFinal2 <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment (&(((juncture)? [y])) / !(Letter)))")

L("SyllableFinal2a <- ((FirstConsonants)? !(RepeatedVocalic) VowelSegment (juncture)? (&([y]) / !(Letter)))")

L("StressedSyllable <- (((FirstConsonants)? !(RepeatedVowel) VowelSegment !(Badfinalpair) (FinalConsonant)? (FinalConsonant)?) [\'])")

L("FinalConsonant <- (!(NonmedialCC) !(NonjointCCC) !(Syllable) C1 !((juncture V2)))")

L("Syllable2 <- (((FirstConsonants2)? (VowelSegment / [y]) !(Badfinalpair) (FinalConsonant2)? (FinalConsonant2)?) (juncture)?)")

L("FinalConsonant2 <- (!(NonmedialCC) !(NonjointCCC) !(Syllable2) C1 !((juncture V2)))")

L("Name <- (([ ])* &(((uppercase / lowercase) ((!((C1 ([\'])? !(Letter))) Lowercase))* C1 ([\'])? !(Letter) (!(.) / ',' / &(period) / &(Name) / &(CI)))) ((Syllable2)+ (!(.) / ',' / &(period) / &(Name))) !((([ ])* [,])))")

L("CCSyllableB <- (((FirstConsonants)? RepeatedVocalic !(Badfinalpair) (FinalConsonant)? (FinalConsonant)?) (juncture)?)")

L("BorrowingTail <- ((!(JunctureFix) StressedSyllable ((!(StressedSyllable) CCSyllableB))? !(StressedSyllable) SyllableFinal1) / (!(CCSyllableB) !(JunctureFix) Syllable ((!(StressedSyllable) CCSyllableB))? !(StressedSyllable) SyllableFinal2))")

L("Borrowing <- (!((C1 V2 (juncture)? &(MaybeInitialCC) C1 (juncture)? &((PreComplex / ComplexTail)))) !((&(BorrowingTail) C1 C1 V2 [\'] V2)) !((&(BorrowingTail) C1 C1 V2 (juncture)? V2 (!(Letter) / ((juncture)? [y])))) &(((((C1)? (V2 (juncture)?) ((V2 (juncture)?))?))? C1 (juncture)? C1)) !(((C1)? V2 (juncture)? (V2)? (juncture)? !(V2) Borrowing)) !((V2 (juncture)? MaybeInitialCC V2)) !(CCSyllableB) (((!(BorrowingTail) !(StressedSyllable) !(JunctureFix) Syllable))* !(CCSyllableB) BorrowingTail))")

L("BorrowingAffix <- (!((C1 V2 (juncture)? &(MaybeInitialCC) C1 (juncture)? &((PreComplex / ComplexTail)))) !((&(BorrowingTail) C1 C1 V2 [\'] V2)) !((&(BorrowingTail) C1 C1 V2 (juncture)? V2 (!(Letter) / ((juncture)? [y])))) &(((((C1)? (V2 (juncture)?) ((V2 (juncture)?))?))? C1 (juncture)? C1)) !(((C1)? V2 (juncture)? (V2)? (juncture)? !(V2) Borrowing)) !((V2 (juncture)? MaybeInitialCC V2)) !(CCSyllableB) (((!(StressedSyllable) !(SyllableFinal2a) !(JunctureFix) Syllable))* SyllableFinal2a) (juncture)? [y] (juncture)? (([ ,] ([ ])*))?)")

L("yhyphen <- ((juncture)? [y] &((([-])? !([y]) letter)))")

L("CV <- ((C1 V2 !(V2)) ([-])?)")

L("Cfinal <- ((C1 yhyphen) / (!(NonmedialCC) !(NonjointCCC) C1 !(((juncture)? V2))))")

L("hyphen <- (!(NonmedialCC) !(NonjointCCC) (([r] !(((juncture)? [r])) !(((juncture)? V2))) / ([n] &(((juncture)? [r]))) / ((juncture)? [y] !([\']))) &(((juncture)? letter)) !(((juncture)? [y])))")

L("CVVStressed <- (((C1 &(RepeatedVowel) V2 ([-])? !(RepeatedVowel) V2 (hyphen)?) (juncture)?) / (C1 !(BrokenMono) V2 [-] V2 [\']) / (C1 !(Mono) V2 V2 [\']))")

L("CVV <- ((C1 !(BrokenMono) V2 (juncture)? !(RepeatedVowel) V2 (hyphen)?) (juncture)?)")

L("CVVFinal1 <- (C1 !(BrokenMono) V2 [\'] V2 (juncture)?)")

L("CVVFinal2 <- (((C1 !(Mono) V2 V2) / (C1 !(BrokenMono) V2 juncture V2)) !(Letter))")

L("CVVFinal3 <- (C1 Mono ([-])?)")

L("CVVFinal4 <- (C1 Mono !(Letter))")

L("CVC <- ((C1 V2 Cfinal) (juncture)?)")

L("CVCStressed <- (C1 V2 !(NonmedialCC) !(NonjointCCC) C1 [\'] (yhyphen)?)")

L("CCV <- (InitialCC !(RepeatedVowel) V2 (yhyphen)? (juncture)?)")

L("CCVStressed <- (InitialCC !(RepeatedVowel) V2 [\'])")

L("CCVFinal1 <- (InitialCC V2 ([-])?)")

L("CCVFinal2 <- (InitialCC V2 !(Letter))")

L("CCVCVMedial <- (CCV C1 [y] &((([-])? letter)) (juncture)?)")

L("CCVCVMedialStressed <- (CCV [\'] C1 [y] &((([-])? letter)) (juncture)?)")

L("CCVCVFinal1 <- (InitialCC V2 [\'] CV)")

L("CCVCVFinal2 <- (InitialCC V2 (juncture)? CV !(Letter))")

L("CVCCVMedial <- (C1 V2 ((juncture &(InitialCC)))? !(NonmedialCC) C1 (juncture)? C1 [y] &((([-])? letter)) (juncture)?)")

L("CVCCVMedialStressed <- ((C1 V2 ([\'] &(InitialCC)) !(NonmedialCC) C1 C1 [y] &((([-])? letter)) (juncture)?) / (C1 V2 !(NonmedialCC) C1 [\'] C1 [y] &((([-])? letter)) (juncture)?))")

L("CVCCVFinal1a <- (C1 V2 [\'] InitialCC V2 (juncture)?)")

L("CVCCVFinal1b <- (C1 V2 !(NonmedialCC) C1 [\'] CV)")

L("CVCCVFinal2 <- (C1 V2 ((juncture &(InitialCC)))? !(NonmedialCC) C1 (juncture)? CV !(Letter))")

L("GenericFinal <- (CVVFinal3 / CVVFinal4 / CCVFinal1 / CCVFinal2)")

L("GenericTerminalFinal <- (CVVFinal4 / CCVFinal2)")

L("Affix <- (CCVCVMedial / CVCCVMedial / CCV / CVV / CVC / BorrowingAffix)")

L("Affix2 <- (!(StressedSyllable) !(CVVStressed) Affix)")

L("ComplexTail <- ((Affix GenericTerminalFinal) / (CCVCVMedialStressed GenericFinal) / (CVCCVMedialStressed GenericFinal) / (CCVStressed GenericFinal) / (CVCStressed GenericFinal) / (CVVStressed GenericFinal) / (Affix2 CVVFinal1) / (Affix2 CVVFinal2) / CCVCVFinal1 / CCVCVFinal2 / CVCCVFinal1a / CVCCVFinal1b / CVCCVFinal2 / (!(((Borrowing !(((juncture)? [y]))) / CVVStressed / StressedSyllable)) Affix !(PreComplex) Borrowing !(((juncture)? [y]))))")

L("Primitive <- (CCVCVFinal1 / CCVCVFinal2 / CVCCVFinal1a / CVCCVFinal1b / CVCCVFinal2)")

L("PreComplex <- ((((!((CVCStressed / CCVStressed / CVVStressed / ComplexTail / StressedSyllable)) Affix))* ComplexTail) / (!(StressedSyllable) BorrowingAffix (PreComplex / (Borrowing !(((juncture)? [y]))))))")

L("Complex <- (!((C1 V2 (juncture)? (V2)? (juncture)? (Primitive / PreComplex / Borrowing / CVV))) !((C1 V2 (juncture)? &(MaybeInitialCC) C1 (juncture)? &((PreComplex / ComplexTail)))) PreComplex)")

L("Predicate <- (&(caprule) (Primitive / Complex / Borrowing) ((([ ])* Z AO ([ ])* Predicate))?)")

L("__LWinit <- (([ ])* !(Predicate) &(caprule))")

L("Oddvowel <- ((juncture)? (((V2 (juncture)? V2 (juncture)?))* V2) (juncture)?)")

L("A0 <- ((([AEOUaeou] !([AEIOUaeiou])) / (__LWinit H a)) (juncture)? !(Oddvowel))")

L("A <- (__LWinit !(Predicate) (((N u) &((u / (N o)))))? ((N o))? A0 ((N OI))? ((PA ((G u) / PAUSE)))? !(Oddvowel))")

L("__LWbreak <- (!(Oddvowel) !((!((([ ])* Predicate)) (A / ICI / ICA / IGE / I))) ((', ' &((([ ])* (V2 / A)))))?)")

L("A1 <- (A __LWbreak)")

L("ACI <- (A (PA)? __LWinit C i __LWbreak)")

L("AGE <- (A (PA)? __LWinit G e __LWbreak)")

L("BI <- (__LWinit ((B IA) / (B IE) / (C IE) / (C IO) / (B IA) / (B [i])) __LWbreak)")

L("CA0 <- (__LWinit ((C a) / (C e) / (C o) / (C u) / (Z e) / (C i H a)) !(Oddvowel))")

L("CA1 <- (__LWinit (((N u) &(((C u) / (N o)))))? ((N o))? CA0 ((N OI))? ((PA ((G u) / PAUSE)))? !(Oddvowel))")

L("CA <- (__LWinit &(caprule) CA1 __LWbreak)")

L("CI <- (__LWinit (C i) __LWbreak)")

L("CUI <- (__LWinit (C UI) __LWbreak)")

L("NI0 <- (((K UA) / (G IE) / (G IU) / (H IE) / (H IU) / (K UE) / (K UA) / (N EA) / (N IO) / (P EA) / (P IO) / (S UU) / (S UA) / (T IA) / (Z OA) / (Z OI) / (H o) / (N i) / (N e) / (T o) / (T e) / (F o) / (F e) / (V o) / (V e) / (P i) / (R e) / (R u) / (S a) / (S e) / (S o) / (S u) / (H i)) !(Oddvowel))")

L("TAI0 <- (((V1 (juncture)? !(Predicate) !(Name) M a (juncture)?) / (V1 (juncture)? !(Predicate) !(Name) F i (juncture)?) / (C1 AI) / (C1 EI) / (C1 EO) / (Z i (juncture)? V1 (juncture)? ((M a))? (juncture)?)) !(Oddvowel))")

L("NI1 <- (NI0 ((M a))? ((M OA (NI0)*))? !(Oddvowel))")

L("RA <- (((R a) / (R i) / (R o)) !(Oddvowel))")

L("IE1 <- (__LWinit IE __LWbreak)")

L("NI <- (__LWinit (IE1)? ((((RA / (NI1 &(NI1))))* NI1) / RA) !((([ ])+ !(Predicate) (NI1 / RA))) (Acronym2)? (((C u) / ((', ')? ([ ])* P UI &(NI))))? !(Oddvowel))")

L("DA0 <- (__LWinit ((T AO) / (T IO) / (T UA) / (M IO) / (M IU) / (M UO) / (M UU) / (T OA) / (T OI) / (T OO) / (T OU) / (T UO) / (T UU) / (S UO) / (H u) / (B a) / (B e) / (B o) / (B u) / (D a) / (D e) / (D i) / (D o) / (D u) / (M i) / (T u) / (M u) / (T i) / (T a) / (M o)) !(Oddvowel))")

L("Acronym <- (&(caprule) (M IE) ([ ])* &(caprule) (!(Oddvowel) / &(TAI0)) !(NI1) ((NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2))))))+ !((([ ])* !(Predicate) (NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2))))))) (([,] &((([ ])+ !(Predicate) (NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2)))))))))?)")

L("Acronym2 <- (&(caprule) (M UE) (!(Oddvowel) / &(TAI0)) !(NI1) ((NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2))))))+ !((([ ])* !(Predicate) (NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2))))))) (((', ')? ([ ])* P UI ([ ])* &((!(Predicate) (NI1 / TAI0 / ([Zz] V2 (!(V2) / ([Zz] &(V2)))))))))?)")

L("TAI <- (__LWinit (TAI0 / ((G AO) !(V2) ([ ])* (Name / Predicate / (C1 V2 V2 (!(Oddvowel) / &(TAI0))) / (C1 V2 (!(Oddvowel) / &(TAI0)))))) __LWbreak)")

L("DA1 <- (__LWinit (TAI0 / DA0) ((C i NI))? !(Oddvowel))")

L("DA <- (__LWinit DA1 __LWbreak)")

L("DIE <- (__LWinit ((D IE) / (F IE) / (K AE) / (N UE) / (R IE)) __LWbreak)")

L("DIO <- (__LWinit ((B EU) / (C AU) / (D IO) / (F OA) / (K AO) / (J UI) / (N EU) / (P OU) / (G OA) / (S AU) / (V EU) / (Z UA) / (Z UE) / (Z UI) / (Z UO) / (Z UU) / (L AE) / (L UE)) __LWbreak)")

L("DJAN <- Name")

L("LIO <- (__LWinit (L IO) __LWbreak)")

L("GA <- (__LWinit (G a) __LWbreak)")

L("GE <- (__LWinit (G e) __LWbreak)")

L("GEU <- (__LWinit ((C UE) / (G EU)) __LWbreak)")

L("GI <- (__LWinit ((G i) / (G OI)) __LWbreak)")

L("GO <- (__LWinit (G o) __LWbreak)")

L("GU <- (__LWinit (G u) __LWbreak)")

L("GUI <- (__LWinit (G UI) __LWbreak)")

L("GUO <- (__LWinit (G UO) __LWbreak)")

L("GUU <- (__LWinit (G UU) __LWbreak)")

L("GUE <- (__LWinit (G UE) __LWbreak)")

L("HOI <- (__LWinit (H OI) __LWbreak)")

L("ICA <- (__LWinit !(Predicate) i ((H a) / CA1) __LWbreak)")

L("ICI <- (__LWinit i (CA1)? __LWinit C i __LWbreak)")

L("IGE <- (__LWinit i (CA1)? __LWinit G e __LWbreak)")

L("JE <- (__LWinit (J e) __LWbreak)")

L("JI <- (__LWinit ((J IE) / (J AE) / (P e) / (J i) / (J a)) __LWbreak)")

L("JIO <- (__LWinit ((J IO) / (J AO)) __LWbreak)")

L("JO <- (__LWinit ((NI0 / RA))? (J o) __LWbreak)")

L("JUE <- (__LWinit (J UE) __LWbreak)")

L("KA0 <- (((K a) / (K e) / (K o) / (K u) / (K i H a)) !(Oddvowel))")

L("KOU <- (((K OU) / (M OI) / (R AU) / (S OA)) !(Oddvowel))")

L("KOU1 <- (((N u) / (N o) / (N u N o)) __LWinit KOU)")

L("KA <- (__LWinit &(caprule) (((((N u) &((K u))))? KA0) / ((KOU1 / KOU) K i)) ((N OI))? __LWbreak)")

L("KI <- (__LWinit (K i) ((N OI))? __LWbreak)")

L("KIE <- (__LWinit (K IE) __LWbreak)")

L("KIU <- (__LWinit (K IU) __LWbreak)")

L("LAU <- (__LWinit ((L AU) / (L OU)) __LWbreak)")

L("Quotemod <- (((Z a) / (Z i)) !(Oddvowel))")

L("LI1 <- (L i)")

L("LU1 <- (L u)")

L("LI <- (__LWinit LI1 !(V2) (Quotemod)? ((([,])? ([ ])+))? utterance0 (', ')? __LWinit LU1 __LWbreak)")

L("stringnospaces <- (([ ])+ ((!([ ,]) !(period) .))+)")

L("LAO1 <- (L AO ([,])?)")

L("LAO <- (LAO1 stringnospaces ((([,])? ([ ])+ [y] ([,])? stringnospaces))* (&([ ,]) / &(period) / !(.)))")

L("LIE1 <- (L IE)")

L("CII1 <- ((C II) / [y])")

L("LIE <- ((([ ])* LIE1 ((!([ ]) NI))? (Quotemod)? stringnospaces ((([ ])* CII1 ((!([ ]) NI))? stringnospaces))*) __LWbreak)")

L("LW <- (&(caprule) (((!(Predicate) V2 V2))+ / ((!(Predicate) (V2)? ((!(Predicate) LWunit))+) / V2)))")

L("LIU0 <- ((L IU) / (N IU))")

L("LIU1 <- (__LWinit ((LIU0 !(V2) (Quotemod)? ((([,])? ([ ])+))? (Name / Predicate / (LW (([,] ([ ])+ !([,])) / &(period) / !(.) / &((([ ])* Predicate)))))) / (L II (Quotemod)? TAI __LWbreak)))")

L("LUA <- (__LWinit ((L UA) / (L UO)) __LWbreak)")

L("SOI <- (__LWinit (S OI) __LWbreak)")

L("ME <- (__LWinit ((M EA) / (M e)) __LWbreak)")

L("LEPO <- (__LWinit ((L e) / (L o) / (NI1)+ / RA) PO1 __LWbreak)")

L("UI0 <- ((UA / UE / UI / UO / UU / OA / OE / OI / OU / IA / II / IO / IU / EA / EI / EO / EU / AE / AI / AO / AU / (B EA) / (B UO) / (C EA) / (C IA) / (C OA) / (D OU) / (F AE) / (F AO) / (F EU) / (G EA) / (K UO) / (K UU) / (R EA) / (N AO) / (N IE) / (P AE) / (P IU) / (S AA) / (S UI) / (T AA) / (T OE) / (V OI) / (Z OU) / (L OI) / (L OA) / (S IA) / (S II) / (T OE) / (S IU) / (C AO) / (C EU) / (S IE)) !(Oddvowel))")

L("NOUI <- ((__LWinit (N o) ([ ])* !(Predicate) UI0 __LWbreak) / (__LWinit UI0 N OI __LWbreak))")

L("NO1 <- (__LWinit !(KOU1) !(NOUI) (N o) !((([ ])* (JIO / JI))) __LWbreak)")

L("NU0 <- (((N UO) / (F UO) / (J UO) / (N u) / (F u) / (J u)) !(Oddvowel))")

L("mex <- (__LWinit NI __LWbreak)")

L("NU <- (__LWinit ((NU0 (NI)? (freemod)?))+ __LWbreak)")

L("PA0 <- (__LWinit ((G IA) / (G UA) / (P IA) / (P UA) / (N IA) / (N UA) / (B IU) / (F EA) / (F IA) / (F UA) / (V IA) / (V II) / (V IU) / (C IU) / (C OI) / (D AU) / (D II) / (D UO) / (F OI) / (F UI) / (G AU) / (H EA) / (K AU) / (K II) / (K UI) / (L IA) / (L UI) / (M IA) / (D II) / (M OU) / (N UI) / (P EU) / (R OI) / (R UI) / (S EA) / (S IO) / (T IE) / (V a) / (V i) / (V u) / (P a) / (N a) / (F a) / (V a) / (V i) / (V u) / KOU) !(Oddvowel))")

L("PA <- (__LWinit ((!(PA0) NI))? ((N OI))? ((KOU1 / PA0))+ (((CA0 ((N OI))?) ((KOU1 / PA0))+))* ((ZI / ((', ')? ([ ])* J UU &(PA))))? !(Oddvowel))")

L("PA2 <- ((__LWinit PA __LWbreak) ((!(PAUSE) freemod))?)")

L("LE <- (__LWinit ((L EA) / (L EU) / (L OE) / (L EE) / (L AA) / (L e) / (L o) / (L a)) ((DA1 / TAI0))? (PA)? __LWbreak)")

L("LA <- (__LWinit (L a) ((DA1 / TAI0))? (PA)? __LWbreak)")

L("I <- (__LWinit i ((PA ((G u) / PAUSE)))? __LWbreak)")

L("GA2 <- (__LWinit (G a) __LWbreak)")

L("PA1 <- (((PA2 / (GA (freemod)?)) __LWbreak) ((!(PAUSE) freemod))?)")

L("CANCELPAUSE <- (',' ([ ])+ (('y,' ([ ])+ !([,])) / (C UU __LWbreak)))")

L("PAUSE <- (!(CANCELPAUSE) [,] ([ ])+ !([,]) !(period) !((A / ICI / ICA / IGE / I)) !((&(V2) Predicate)))")

L("PO1 <- (__LWinit ((P o) / (P u) / (Z o)) !(Oddvowel))")

L("POSHORT1 <- (__LWinit ((P OI) / (P UU) / (Z OO) / (P o) / (P u) / (Z o)) !(Oddvowel))")

L("PO <- (__LWinit PO1 __LWbreak)")

L("POSHORT <- (__LWinit POSHORT1 __LWbreak)")

L("LWPREDA <- (((H e) / (D UA) / (D UI) / (B UA) / (B UI)) !(Oddvowel))")

L("PREDA <- (([ ])* &(caprule) (Predicate / LWPREDA / Acronym / (!([ ]) NI RA)) !((A / ICI / ICA / IGE / I)) ((',' ([ ])+ &((V2 / A))))? ((!(PAUSE) freemod))?)")

L("UI1 <- (__LWinit (UI0 / (PA H u) / (NI F i)) __LWbreak)")

L("HUE <- (__LWinit (H UE) __LWbreak)")

L("SUE <- (__LWinit ((S UE) / (S AO)) ([ ])+ (letter)* __LWbreak)")

L("ZE2 <- (__LWinit (Z e) __LWbreak)")

L("ZI <- ((Z i) / (Z a) / (Z u))")

L("guo <- ((((PAUSE)? (GUO / GU) (PAUSE)?) / PAUSE) (freemod)?)")

L("gui <- ((((PAUSE)? (GUI / GU) (PAUSE)?) / PAUSE) (freemod)?)")

L("gue <- ((((PAUSE)? (GUE / GU) (PAUSE)?) / PAUSE) (freemod)?)")

L("guu <- ((((PAUSE)? (GUU / GU) (PAUSE)?) / PAUSE) (freemod)?)")

L("guu1 <- ((((PAUSE)? GUU (PAUSE)?) / PAUSE) (freemod)?)")

L("lua <- LUA")

L("geu <- GEU")

L("gap <- ((((PAUSE)? GU (PAUSE)?) / PAUSE) (freemod)?)")

L("juelink <- (JUE (freemod)? term)")

L("links1 <- (juelink (links1)? (gue)?)")

L("links <- ((links1 / (KA (freemod)? links KI (freemod)? links1)) ((A1 (freemod)? links1))*)")

L("jelink <- (JE (freemod)? term)")

L("linkargs1 <- (jelink (links)? (gue)?)")

L("linkargs <- ((linkargs1 / (KA (freemod)? linkargs KI (freemod)? linkargs1)) ((A1 (freemod)? linkargs1))*)")

L("predunit1 <- ((SUE / (NU (freemod)? GE (freemod)? despredE (geu)?) / (NU (freemod)? PREDA) / (GE (freemod)? descpred (geu)?) / (ME (freemod)? argument (gap)?) / PREDA) ((!(PAUSE) freemod))?)")

L("predunit2 <- (((NO1 (freemod)?))* predunit1)")

L("NO2 <- (!(predunit2) NO1)")

L("predunit3 <- ((predunit2 linkargs) / predunit2)")

L("predunit <- (((POSHORT ((!(PAUSE) freemod))?))? predunit3)")

L("kekpredunit <- (((NO1 (freemod)?))* KA (freemod)? predicate KI (freemod)? predicate)")

L("despredA <- ((predunit ((CI (freemod)? despredA))?) / kekpredunit)")

L("despredB <- ((!(PREDA) CUI (freemod)? despredC CA (freemod)? despredB) / despredA)")

L("despredC <- (despredB)+")

L("despredD <- (despredB ((CA (freemod)? despredB))*)")

L("despredE <- (despredD)+")

L("descpred <- ((despredE GO (freemod)? descpred) / despredE)")

L("senpred1 <- ((predunit CI (freemod)? senpred1) / predunit)")

L("senpred2 <- (senpred1 / (CUI (freemod)? despredC CA (freemod)? despredB))")

L("senpred3 <- (senpred2 ((CA (freemod)? despredB))*)")

L("senpred4 <- (senpred3 (despredD)*)")

L("sentpred <- ((senpred4 GO (freemod)? barepred) / senpred4)")

L("mod1 <- ((PA2 argument (gap)?) / (PA2 !(barepred) (guu1)?))")

L("kekmod <- (((NO1 (freemod)?))* (KA (freemod)? modifier KI (freemod)? mod))")

L("mod <- (mod1 / (((NO1 (freemod)?))* mod1) / kekmod)")

L("modifier <- ((mod / kekmod) ((A1 (freemod)? mod))*)")

L("namemarker <- (([ ])* ((L a) / (H OI) / (C i) / (H UE) / (L IU) / (G AO)))")

L("nonamemarkers <- (([ ])* ((!(namemarker) Letter))+ !(Letter))")

L("name <- ((DJAN (((([ ])* (C i) ((',' ([ ])+))? DJAN) / (C i (freemod)? DJAN) / (C i (freemod)? predunit) / (&(nonamemarkers) DJAN)))*) (freemod)?)")

L("LA0 <- (L a)")

L("LANAME <- (([ ])* LA0 ((',' ([ ])+))? name (gap)?)")

L("HOI0 <- (H OI)")

L("voc <- ((([ ])* HOI0 ((',' ([ ])+))? name (gap)?) / (HOI (freemod)? name (gap)?) / (HOI (freemod)? descpred (gap)?) / (HOI (freemod)? argument (gap)?) / (HOI (gap)?))")

L("descriptn <- (!(LANAME) ((LE (freemod)? descpred) / (LE (freemod)? mex (freemod)? descpred) / (LE (freemod)? arg1 descpred) / (LE (freemod)? mex (freemod)? arg1a) / (GE (freemod)? mex (freemod)? descpred)))")

L("arg1 <- ((LEPO (freemod)? uttAx (guo)?) / (LEPO (freemod)? sentence (guo)?) / (LIO (freemod)? descpred (gap)?) / (LIO (freemod)? term (gap)?) / (LIO (freemod)? mex (gap)?) / LAO / LANAME / (!(LANAME) LA (freemod)? name (gap)?) / (descriptn (name)? (gap)?) / LIU1 / LIE / LI)")

L("arg1a <- ((DA / TAI / arg1 / (GE (freemod)? arg1a)) ((!(PAUSE) freemod))?)")

L("argmod1 <- (((__LWinit (N o) ([ ])*))? ((JI (freemod)? predicate (gui)?) / (JIO (freemod)? sentence (gui)?) / (JIO (freemod)? uttAx (gui)?) / (JI (freemod)? modifier) / (JI (freemod)? argument)))")

L("argmod <- (argmod1 ((A1 (freemod)? argmod1 (gap)?))*)")

L("arg2 <- (arg1a ((argmod (gap)?))*)")

L("arg3 <- (arg2 / (mex (freemod)? arg2))")

L("indef1 <- (mex (freemod)? descpred)")

L("indef2 <- (indef1 (gap)? ((argmod (gap)?))*)")

L("indefinite <- indef2")

L("arg4 <- ((arg3 / indefinite) ((ZE2 (freemod)? (arg3 / indefinite)))*)")

L("arg5 <- (arg4 / (KA (freemod)? argument KI (freemod)? argx))")

L("arg6 <- (arg5 / (DIO (freemod)? arg6) / (IE1 (freemod)? arg6))")

L("argx <- (((NO1 (freemod)?))* arg6)")

L("arg7 <- (argx ((ACI (freemod)? arg7))?)")

L("arg8 <- (!(GE) (arg7 ((A1 (freemod)? arg7))*))")

L("argument <- (((LAU wordset) / (arg8 AGE (freemod)? argument) / arg8) ((GUU (freemod)? argmod (gap)?))*)")

L("term <- (argument / modifier)")

L("terms <- (term)+")

L("word <- ((arg1a (gap)?) / (UI1 (gap)?) / (NI (gap)?) / (PA2 (gap)?) / (DIO (gap)?) / (predunit1 (gap)?) / indef2)")

L("words <- (word)+")

L("wordset <- ((words)? lua)")

L("termset1 <- ((terms (guu)?) / (KA (freemod)? termset2 (freemod)? KI (freemod)? termset1))")

L("termset2 <- (termset1 ((A1 (freemod)? termset1))*)")

L("termset <- ((terms (freemod)? GO (freemod)? barepred) / termset2 / guu)")

L("kekpred <- (kekpredunit (((freemod)? despredD))*)")

L("barepred <- ((sentpred (freemod)? (termset)?) / (kekpred (freemod)? (termset)?))")

L("markpred <- ((PA1 barepred) / (PO (gap)? sentence (gap)?))")

L("backpred1 <- (((NO2 (freemod)?))* (barepred / markpred))")

L("backpred <- (((backpred1 ((ACI (freemod)? backpred1))+ (freemod)? (termset)?) ((((ACI (freemod)? backpred))+ (freemod)? (termset)?))?) / backpred1)")

L("predicate2 <- (!(GE) (((backpred ((A1 !(GE) (freemod)? backpred))+ (freemod)? (termset)?) ((((A1 (freemod)? predicate2))+ (freemod)? (termset)?))?) / backpred))")

L("predicate1 <- ((predicate2 AGE (freemod)? predicate1) / predicate2)")

L("identpred <- (((NO1 (freemod)?))* (BI (freemod)? termset))")

L("predicate <- (predicate1 / identpred)")

L("gasent <- (((NO1 (freemod)?))* (PA1 (freemod)? barepred GA2 (freemod)? terms))")

L("statement <- (gasent / (terms (freemod)? gasent) / (terms (freemod)? predicate))")

L("keksent <- (((NO1 (freemod)?))* ((KA (freemod)? sentence KI (freemod)? uttA1) / (KA (gap)? sentence KI (freemod)? uttA1) / (KA (freemod)? headterms (freemod)? sentence KI (freemod)? uttA1)))")

L("sen1 <- (statement / predicate / keksent)")

L("sentence <- (sen1 ((ICA sen1))*)")

L("headterms <- ((terms GI))+")

L("uttA <- ((A1 / IE1 / mex) ((!(PAUSE) freemod))?)")

L("uttAx <- (headterms (freemod)? sentence (gap)?)")

L("uttA1 <- ((sen1 / uttAx / NO1 / links / linkargs / argmod / (terms (freemod)? keksent) / terms / uttA) (period)?)")

L("freemod <- ((NOUI / UI1 / (SOI (freemod)? descpred (gap)?) / DIE / (NO1 DIE) / (KIE utterance0 KIU) / (([ ])* (H UE) ((',' ([ ])+))? name (gap)?) / (HUE (freemod)? name (gap)?) / (HUE (freemod)? statement (gap)?) / (HUE (freemod)? terms (gap)?) / voc / CANCELPAUSE / PAUSE / JO) (freemod)?)")

L("neghead <- (NO1 gap)")

L("uttC <- ((neghead uttC) / uttA1)")

L("uttD <- (uttC ((ICI (freemod)? uttD))*)")

L("uttE <- (uttD ((ICA (freemod)? uttD))*)")

L("uttF <- (uttE ((I (freemod)? uttF))*)")

L("utterance0 <- ((!(PAUSE) freemod (period)? utterance0) / (!(PAUSE) freemod (period)?) / (uttE IGE utterance0) / (I (freemod)?) / uttF / (I (freemod)? uttF) / (ICA (freemod)? uttF))")

L("utterance <- ((!(PAUSE) freemod (period)? utterance) / (!(PAUSE) freemod (period)? !(.)) / (uttE IGE utterance) / (I (freemod)? (period)? !(.)) / (uttF !(.)) / (I (freemod)? uttF !(.)) / (ICA (freemod)? uttF !(.)))")

if __name__ == '__main__':interface();
